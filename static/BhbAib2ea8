 static async edit(
    company,
    id: string,
    body: IEditLocationRequest
  ): Promise<ILocationDocument | BaseError> {
    const { locations, title } = body;
    const object = await Location.findOne({
      company,
      $or: [{ _id: id }, { title }],
    });
    console.log(locations);

    if (!object) {
      throw NotFound("location");
    }

    const data = {
      title: body.title || object.title,
      locations: removeRepeatable(locations),
    };
    const addedLocations = locations.filter(function (loc) {
      !loc.hasOwnProperty("id");
    });
    const onlyExisted = object.locations.filter(function (loc) {
      locations.includes(loc);
    });
    const idLocUpdateB = locations
      .filter(function (loc) {
        !addedLocations.includes(loc);
      })
      .map(function (loc: ILocationEdit) {
        if (!onlyExisted.includes(loc)) {
          return loc.id;
        }
      });
    const locUpdateB = locations
      .map(function (loc: ILocationEdit) {
        if (idLocUpdateB.includes(loc.id)) {
          return loc;
        }
      })
      .sort((x, y) => Number(x.id) - Number(y.id));

    const updatedLoc = object.locations
      .map(function (loc: ILocationEdit) {
        if (idLocUpdateB.includes(loc.id)) {
          return loc;
        }
      })
      .sort((x, y) => Number(x.id) - Number(y.id));

    const deletedLocations = object.locations.map(function (
      loc: ILocationEdit
    ) {
      if (!updatedLoc.includes(loc) && !onlyExisted.includes(loc)) {
        return loc;
      }
    });

    if (deletedLocations.length > 0) {
      await Item.updateMany(
        {
          company,
          "metadata.object": object.title,
          "metadata.location": {
            $in: deletedLocations.map(function (loc) {
              if (loc.hasOwnProperty("title")) {
                return loc.title;
              }
              return loc;
            }),
          },
        },
        {
          "metadata.location": "",
        }
      );
    }

    const editPromises = [];
    for (let i = 0; i < updatedLoc.length; i++) {
      const prevLocation = updatedLoc[i].title;
      const newLocation = locUpdateB[i].title;

      const editItemsPromise = Item.updateMany(
        {
          company,
          "metadata.object": object.title,
          "metadata.location": prevLocation,
        },
        {
          "metadata.location": newLocation,
        }
      );

      editPromises.push(editItemsPromise);
    }

    if (editPromises.length > 0) {
      await Promise.all(editPromises);
    }

    if (object.title !== body.title) {
      await Item.updateMany(
        {
          company,
          "metadata.object": object.title,
        },
        {
          "metadata.object": body.title,
        }
      );
    }

    await object.update({
      title: title.trim(),
      locations: locations.map(function (loc) {
        if (addedLocations.includes(loc)) {
          return { id: new Types.ObjectId(), title: loc.title };
        } else return loc;
      }),
    });
    return { ...object.toJSON(), ...data } as ILocationDocument;
  }


export interface ILocationEdit {
  id: Types.ObjectId;
  title: string;
}



export interface IEditLocationRequest {
  title: string;
  locations?: Array<{ id: Types.ObjectId; title: string } | { title: string }>;
}